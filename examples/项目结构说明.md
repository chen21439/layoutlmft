# models/

放“可学习的网络结构与可复用的前向计算组件”。

backbone.py：通用编码器（Transformer/布局编码/图编码等）

heads.py：各任务 head（分类头、span 头、关系打分头等）

build.py：build_model(cfg) 工厂，根据配置拼装 backbone + heads + 可选组件

也适合放：modules/ 或 components/（例如 attention、pooling、memory bank、similarity 计算）

不放：训练循环、指标汇总、文件读写、结果导出。

# tasks/

放“任务定义层”：同一模型输出如何转成 loss / decode / metric。

base.py：Task 接口（loss() / decode() / metrics() 等）

semantic_cls.py / parent_finding.py / relation_cls.py：各任务的损失、标签对齐、解码策略、任务特有的后处理

不放：底层网络层实现（那是 models/）、通用训练循环（那是 engines/）。

# engines/

放“运行骨架”：训练/推理/评估的循环与工程能力。

runner.py：统一的 run_loop(mode)，处理 device、AMP、DDP、梯度累积、日志回调

trainer.py：优化器/学习率计划/断点续训/保存 ckpt

predictor.py：推理管线（批处理、beam/topk、导出格式、可选的加速/缓存）

evaluator.py：评估管线（聚合、对齐、生成 report、分布式 gather）

不放：任务损失细节、不放模型结构细节。

# metrics/

放“纯指标实现”：可复用、可单测。

common.py：accuracy/F1/PR、top-k、confusion matrix 等

registry.py：指标注册表（按配置选择指标）

不放：模型推理、数据读取。

# utils/

放“横切能力与基础设施”。

config.py：配置解析/校验/合并/保存 resolved config

distributed.py：DDP 初始化、gather、barrier

logging.py：logger、tensorboard/wandb 封装

seed.py：随机性控制

io.py：通用读写（jsonl/parquet）、结果对齐工具、run_dir 产物管理

不放：具体任务逻辑、模型结构。

# data/（你前面问的那个）

放“从原始样本到 batch”全链路：dataset/transforms/collate/dataloader 装配。

scripts/

只放极薄入口。

train.py / predict.py / evaluate.py：解析参数→读配置→调用 engines 启动
原则：脚本尽量不出现业务 if/else。