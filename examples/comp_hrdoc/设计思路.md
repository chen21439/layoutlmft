# Comp_HRDoc 项目设计思路

## 数据

- **Comp_HRDoc** 数据集
- 每个文档包含多行（line），每行有：text、bbox、类别（section/para/fig/tab...）
- **标注**：section 之间的父子关系、左兄弟关系

## 模型流程

```
文本+位置 → LayoutXLM → token embeddings → mean pool → line embeddings
                                                          ↓
                                           只取 section 类的 lines
                                                          ↓
                                         RoPE Transformer (N层)
                                                          ↓
                                           TreeRelationHead
                                            ├── Parent Head
                                            └── Sibling Head
```

## RoPE Transformer

### 结构（每层）
```
Input [B, S, H]
    ↓
LayerNorm
    ↓
┌─────────────────────────────────────┐
│  Self-Attention with RoPE           │
│  Q = W_q(x), K = W_k(x), V = W_v(x) │
│  Q', K' = apply_rope(Q, K, pos)     │
│  Attn = softmax(Q'K'^T / √d) · V    │
│  Output = W_o(Attn)                 │
└─────────────────────────────────────┘
    ↓ (+residual)
LayerNorm
    ↓
┌─────────────────────────────────────┐
│  FFN                                │
│  Linear(H→4H) → GELU → Linear(4H→H) │
└─────────────────────────────────────┘
    ↓ (+residual)
Output [B, S, H]
```

### 关键参数
- `hidden_size`: 768
- `num_heads`: 12
- `num_layers`: 3（默认）
- `ffn_dim`: 3072 (4 × hidden_size)
- `scale`: head_dim^(-0.5) = (768/12)^(-0.5) = 64^(-0.5)

### RoPE 位置编码
- 使用 reading order 作为位置输入
- 对 Q, K 应用旋转位置编码
- 编码 section 在文档中的相对顺序

## TreeRelationHead（两个预测头）

### 结构
```
features [B, S, H]
         ↓
    ┌────┴────┐
    ↓         ↓
Parent Head  Sibling Head
    ↓         ↓
┌─────────┐ ┌─────────┐
│ W_q [H,H]│ │ W_q [H,H]│  ← 全连接层（无bias默认）
│ W_k [H,H]│ │ W_k [H,H]│
└─────────┘ └─────────┘
    ↓         ↓
 Q·K^T/√H   Q·K^T/√H
    ↓         ↓
[B, S, S]  [B, S, S]
```

### 1. Parent Head
```python
Q = W_q(features)           # [B, S, H]
K = W_k(features)           # [B, S, H]
parent_logits = Q @ K^T * scale  # [B, S, S]
# parent_logits[i, j] = j 是 i 的父节点的得分
```
- **自指向（i==j）表示 ROOT**
- 对角线不 mask，允许学习自指向

### 2. Sibling Head
```python
Q = W_q(features)           # [B, S, H]
K = W_k(features)           # [B, S, H]
sibling_logits = Q @ K^T * scale  # [B, S, S]
# sibling_logits[i, j] = j 是 i 的左兄弟的得分
```
- **自指向表示无左兄弟**
- **上三角 mask**：左兄弟只能从前面的节点选（j ≤ i）

## Mask 策略

| 位置 | Parent Head | Sibling Head |
|------|-------------|--------------|
| 对角线 | ✓ 保留（ROOT自指向） | ✓ 保留（无左兄弟） |
| 上三角 | ✓ 保留 | ✗ mask（j > i 不合法） |
| 无效节点 | ✗ mask (-1e4) | ✗ mask (-1e4) |

## 格式转换

| 格式 | 字段 | 含义 | 用途 |
|------|------|------|------|
| 格式 A | ref_parent, relation | 参考父节点 + 关系类型 | 训练数据标注 |
| 格式 B | hierarchical_parent, left_sibling | 自指向方案 | 模型预测输出 |

**自指向约定**：
- `parent[i] = i` → 节点 i 是 ROOT
- `sibling[i] = i` → 节点 i 无左兄弟

## 解码算法：Tree Insertion Decode

推理时使用 Algorithm 1（论文）进行联合解码：

```
for i in 0..N:
    1. 获取候选父节点 = 当前树的"最右路径"上的节点
    2. 从候选中选择 parent_logits 最高的作为父节点
    3. 选择左兄弟（从父节点的已有子节点中选）
    4. 将节点 i 插入树中
```

**最右路径约束**：保证生成的树结构合法

## 损失函数

```python
loss = CE(parent_logits, gt_parents) + CE(sibling_logits, gt_siblings)
```

- 交叉熵损失
- 两个 head 的 loss 直接相加（权重 1:1）

## 核心设计点

1. **只学习相对关系**
   - 没有绝对层级概念（不知道"册"比"章"高）
   - Parent/Sibling 关系是相对的，由上下文决定

2. **Mean Pooling 的信息损失**
   - Token embeddings → Line embeddings 使用 mean pool
   - 关键 token（如"册"、"章"）的信息被平均稀释
   - 一行 20 个 token，"册"只占 1/20 权重

3. **Query-Key 机制**
   - 类似 Attention，但不做 softmax 后加权
   - 直接用 logits 做分类
   - scale factor 防止梯度消失

4. **位置信息来源**
   - RoPE 编码 reading order（section 顺序）
   - 不直接使用 bbox 空间位置

## 已知问题

**"第二册"预测错误**：
- "第一册" 能正确预测 parent=自身（ROOT）
- "第二册" 预测 parent=自身 的得分低，被错误放到其他节点下

**可能原因**：
1. Mean pooling 后，"一" vs "二" 的 embedding 差异被稀释
2. RoPE 位置编码影响了上下文表示（第二册位置靠后）
3. 训练数据中类似 pattern 不足
4. Query-Key 线性变换没有学到区分"首个"vs"非首个"同类节点

**可能的改进方向**：
- 加权 pooling（给开头 token 更高权重）
- Attention pooling 代替 mean pooling
- 增加训练数据中的多册样本
- 显式的位置特征（是否是同类节点中的第一个）

---

## Stage 与 Comp_HRDoc 的关系

### 两套代码的区别

| 项目 | examples/stage | examples/comp_hrdoc |
|------|----------------|---------------------|
| 论文 | HRDoc 原论文 | DOC (Detect-Order-Construct) |
| Backbone | LayoutXLM | LayoutXLM（共用） |
| Line Pooling | Mean Pooling | Mean Pooling（共用） |
| 层级预测 | Stage 3: ParentFinder (GRU) | Construct: RoPE Transformer + TreeRelationHead |
| 关系预测 | Stage 4: RelationClassifier | 集成在 Construct 中 |
| 训练方式 | 端到端联合训练 | 分阶段训练 or 使用 stage 特征 |

### Stage 模型结构 (train_joint.py)

```
LayoutXLM Backbone
       ↓
   LinePooling (mean pool)
       ↓
   Line Features [L, 768]
       ↓
  ┌────┼────┐
  ↓    ↓    ↓
Stage1 Stage3 Stage4
(分类) (Parent) (Relation)
  ↓    ↓    ↓
L_cls L_par L_rel
       ↓
Total Loss = λ1*L_cls + λ2*L_par + λ3*L_rel
```

### Comp_HRDoc 模型结构 (train_doc.py)

```
预提取的 Region Features
  或
Stage 模型特征 (--use-stage-features)
       ↓
   Order Module (可选)
       ↓
  Construct Module
       ↓
  RoPE Transformer
       ↓
  TreeRelationHead
   ├── Parent Head
   └── Sibling Head
       ↓
L_parent + L_sibling
```

### 当前集成方式

**现状**：`--use-stage-features` 模式
```python
# 使用训练好的 stage 模型提取特征
stage_feature_extractor = StageFeatureExtractor(
    checkpoint_path=args.stage_checkpoint
)
line_features = stage_feature_extractor.extract_features(batch)
# 然后送入 Construct 模块训练
```

**问题**：
- 不是端到端训练，梯度不回传到 backbone
- Stage 模型和 Construct 模块分开优化

### 联合训练方案（TODO）

**目标**：将 Stage backbone 和 Construct 模块端到端联合训练

```
LayoutXLM Backbone (共享)
       ↓
   LinePooling
       ↓
   Line Features
       ↓
  ┌────┴────┐
  ↓         ↓
Stage3/4   Construct
(GRU)     (RoPE+TreeHead)
  ↓         ↓
L_stage   L_construct
       ↓
Total Loss = λ1*L_stage + λ2*L_construct
```

**实现要点**：
1. 复用 `examples/stage/models/joint_model.py` 的 backbone + line_pooling
2. 添加 `ConstructModule` 作为新的 head
3. 设计合理的 loss 权重
4. 可选：保留 Stage3/4 做多任务学习，或只用 Construct

**代码路径**：
- Stage 模型：`examples/stage/models/joint_model.py`
- Construct 模块：`examples/comp_hrdoc/models/construct.py`
- 特征提取器：`examples/comp_hrdoc/utils/stage_feature_extractor.py`

---

## Stage1 联合训练实现

### 新增参数

```python
# train_doc.py 新增参数
parser.add_argument("--train-stage1", action="store_true", default=False,
                    help="Enable Stage1 (LayoutXLM) joint training with Construct")
parser.add_argument("--layoutxlm-path", type=str, default="microsoft/layoutxlm-base",
                    help="LayoutXLM model path (HuggingFace or local)")
parser.add_argument("--stage1-lr", type=float, default=5e-5,
                    help="Learning rate for Stage1 backbone")
parser.add_argument("--freeze-backbone", action="store_true", default=False,
                    help="Freeze LayoutXLM backbone, only train cls_head + Construct")
parser.add_argument("--lambda-cls", type=float, default=1.0,
                    help="Weight for Stage1 classification loss")
```

### 复用模块

```python
# 从 stage 复用
from examples.stage.models.modules import LinePooling
from examples.stage.models.heads import LineClassificationHead

# 或完整模型
from examples.stage.models.stage1_line_level_model import LayoutXLMForLineLevelClassification
```

### 联合模型结构

```python
class DOCModelWithStage1(nn.Module):
    def __init__(self, layoutxlm_model, construct_model, num_classes=14):
        # Stage1 组件
        self.backbone = layoutxlm_model          # LayoutXLM
        self.line_pooling = LinePooling()        # 共享模块
        self.cls_head = LineClassificationHead() # 共享模块

        # Construct 组件
        self.construct = construct_model         # RoPE Transformer + TreeHead

    def forward(self, input_ids, bbox, attention_mask, line_ids, ...):
        # Stage1: 提取 line features
        hidden = self.backbone(input_ids, bbox, attention_mask)
        line_features, mask = self.line_pooling(hidden, line_ids)
        cls_logits = self.cls_head(line_features)
        cls_loss = CE(cls_logits, line_labels)

        # 过滤 section
        section_features = line_features[section_mask]

        # Construct: 预测 parent/sibling
        construct_out = self.construct(section_features, ...)
        construct_loss = construct_out["loss"]

        # 联合 loss
        total_loss = lambda_cls * cls_loss + lambda_construct * construct_loss
        return total_loss, cls_logits, construct_out
```

### 训练流程

```
1. 加载 LayoutXLM (--layoutxlm-path)
2. 初始化 LinePooling + LineClassificationHead
3. 初始化 ConstructModule (RoPE Transformer + TreeHead)
4. 优化器参数组:
   - backbone: lr=stage1_lr (可选 freeze)
   - cls_head: lr=stage1_lr
   - construct: lr=learning_rate
5. 训练循环:
   - Forward: backbone → line_pooling → cls_head → construct
   - Loss: λ1*L_cls + λ2*L_construct
   - Backward & Update
```

### 配置要求

| 配置项 | 来源 | 说明 |
|--------|------|------|
| layoutxlm_path | configs/{env}.yml 或命令行 | LayoutXLM 模型路径 |
| num_classes | 固定 14 或从 labels.py | 分类类别数 |
| tokenizer | 与 layoutxlm_path 相同 | 分词器 |

### 使用方法

```bash
# 基础 Stage1 + Construct 联合训练
python examples/comp_hrdoc/scripts/train_doc.py \
    --env test \
    --train-stage1 \
    --layoutxlm-path /path/to/layoutxlm \
    --stage1-lr 5e-5 \
    --learning-rate 1e-4 \
    --lambda-cls 1.0 \
    --construct-weight 1.0

# 冻结 backbone，只训练 cls_head + Construct
python examples/comp_hrdoc/scripts/train_doc.py \
    --env test \
    --train-stage1 \
    --freeze-backbone \
    --learning-rate 1e-4

# 快速测试
python examples/comp_hrdoc/scripts/train_doc.py \
    --env test \
    --train-stage1 \
    --quick
```

### 实现文件

- **模型**: `examples/comp_hrdoc/models/joint_with_stage1.py`
  - `JointModelWithStage1`: 联合模型类
  - `build_joint_model_with_stage1`: 模型构建函数

- **训练**: `examples/comp_hrdoc/scripts/train_doc.py`
  - `train_epoch_with_stage1()`: Stage1 训练循环
  - `evaluate_with_stage1()`: Stage1 评估函数
