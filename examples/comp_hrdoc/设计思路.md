# Comp_HRDoc 项目设计思路

## 数据

- **Comp_HRDoc** 数据集
- 每个文档包含多行（line），每行有：text、bbox、类别（section/para/fig/tab...）
- **标注**：section 之间的父子关系、左兄弟关系

## 模型流程

```
文本+位置 → LayoutXLM → token embeddings → mean pool → line embeddings
                                                          ↓
                                           只取 section 类的 lines
                                                          ↓
                                         RoPE Transformer (N层)
                                                          ↓
                                           TreeRelationHead
                                            ├── Parent Head
                                            └── Sibling Head
```

## RoPE Transformer

### 结构（每层）
```
Input [B, S, H]
    ↓
LayerNorm
    ↓
┌─────────────────────────────────────┐
│  Self-Attention with RoPE           │
│  Q = W_q(x), K = W_k(x), V = W_v(x) │
│  Q', K' = apply_rope(Q, K, pos)     │
│  Attn = softmax(Q'K'^T / √d) · V    │
│  Output = W_o(Attn)                 │
└─────────────────────────────────────┘
    ↓ (+residual)
LayerNorm
    ↓
┌─────────────────────────────────────┐
│  FFN                                │
│  Linear(H→4H) → GELU → Linear(4H→H) │
└─────────────────────────────────────┘
    ↓ (+residual)
Output [B, S, H]
```

### 关键参数
- `hidden_size`: 768
- `num_heads`: 12
- `num_layers`: 3（默认）
- `ffn_dim`: 3072 (4 × hidden_size)
- `scale`: head_dim^(-0.5) = (768/12)^(-0.5) = 64^(-0.5)

### RoPE 位置编码
- 使用 reading order 作为位置输入
- 对 Q, K 应用旋转位置编码
- 编码 section 在文档中的相对顺序

## TreeRelationHead（两个预测头）

### 结构
```
features [B, S, H]
         ↓
    ┌────┴────┐
    ↓         ↓
Parent Head  Sibling Head
    ↓         ↓
┌─────────┐ ┌─────────┐
│ W_q [H,H]│ │ W_q [H,H]│  ← 全连接层（无bias默认）
│ W_k [H,H]│ │ W_k [H,H]│
└─────────┘ └─────────┘
    ↓         ↓
 Q·K^T/√H   Q·K^T/√H
    ↓         ↓
[B, S, S]  [B, S, S]
```

### 1. Parent Head
```python
Q = W_q(features)           # [B, S, H]
K = W_k(features)           # [B, S, H]
parent_logits = Q @ K^T * scale  # [B, S, S]
# parent_logits[i, j] = j 是 i 的父节点的得分
```
- **自指向（i==j）表示 ROOT**
- 对角线不 mask，允许学习自指向

### 2. Sibling Head
```python
Q = W_q(features)           # [B, S, H]
K = W_k(features)           # [B, S, H]
sibling_logits = Q @ K^T * scale  # [B, S, S]
# sibling_logits[i, j] = j 是 i 的左兄弟的得分
```
- **自指向表示无左兄弟**
- **上三角 mask**：左兄弟只能从前面的节点选（j ≤ i）

## Mask 策略

| 位置 | Parent Head | Sibling Head |
|------|-------------|--------------|
| 对角线 | ✓ 保留（ROOT自指向） | ✓ 保留（无左兄弟） |
| 上三角 | ✓ 保留 | ✗ mask（j > i 不合法） |
| 无效节点 | ✗ mask (-1e4) | ✗ mask (-1e4) |

## 格式转换

| 格式 | 字段 | 含义 | 用途 |
|------|------|------|------|
| 格式 A | ref_parent, relation | 参考父节点 + 关系类型 | 训练数据标注 |
| 格式 B | hierarchical_parent, left_sibling | 自指向方案 | 模型预测输出 |

**自指向约定**：
- `parent[i] = i` → 节点 i 是 ROOT
- `sibling[i] = i` → 节点 i 无左兄弟

## 解码算法：Tree Insertion Decode

推理时使用 Algorithm 1（论文）进行联合解码：

```
for i in 0..N:
    1. 获取候选父节点 = 当前树的"最右路径"上的节点
    2. 从候选中选择 parent_logits 最高的作为父节点
    3. 选择左兄弟（从父节点的已有子节点中选）
    4. 将节点 i 插入树中
```

**最右路径约束**：保证生成的树结构合法

## 损失函数

```python
loss = CE(parent_logits, gt_parents) + CE(sibling_logits, gt_siblings)
```

- 交叉熵损失
- 两个 head 的 loss 直接相加（权重 1:1）

## 核心设计点

1. **只学习相对关系**
   - 没有绝对层级概念（不知道"册"比"章"高）
   - Parent/Sibling 关系是相对的，由上下文决定

2. **Mean Pooling 的信息损失**
   - Token embeddings → Line embeddings 使用 mean pool
   - 关键 token（如"册"、"章"）的信息被平均稀释
   - 一行 20 个 token，"册"只占 1/20 权重

3. **Query-Key 机制**
   - 类似 Attention，但不做 softmax 后加权
   - 直接用 logits 做分类
   - scale factor 防止梯度消失

4. **位置信息来源**
   - RoPE 编码 reading order（section 顺序）
   - 不直接使用 bbox 空间位置

## 已知问题

**"第二册"预测错误**：
- "第一册" 能正确预测 parent=自身（ROOT）
- "第二册" 预测 parent=自身 的得分低，被错误放到其他节点下

**可能原因**：
1. Mean pooling 后，"一" vs "二" 的 embedding 差异被稀释
2. RoPE 位置编码影响了上下文表示（第二册位置靠后）
3. 训练数据中类似 pattern 不足
4. Query-Key 线性变换没有学到区分"首个"vs"非首个"同类节点

**可能的改进方向**：
- 加权 pooling（给开头 token 更高权重）
- Attention pooling 代替 mean pooling
- 增加训练数据中的多册样本
- 显式的位置特征（是否是同类节点中的第一个）

---

## Stage 与 Comp_HRDoc 的关系

### 两套代码的区别

| 项目 | examples/stage | examples/comp_hrdoc |
|------|----------------|---------------------|
| 论文 | HRDoc 原论文 | DOC (Detect-Order-Construct) |
| Backbone | LayoutXLM | LayoutXLM（共用） |
| Line Pooling | Mean Pooling | Mean Pooling（共用） |
| 层级预测 | Stage 3: ParentFinder (GRU) | Construct: RoPE Transformer + TreeRelationHead |
| 关系预测 | Stage 4: RelationClassifier | 集成在 Construct 中 |
| 训练方式 | 端到端联合训练 | 分阶段训练 or 使用 stage 特征 |

### Stage 模型结构 (train_joint.py)

```
LayoutXLM Backbone
       ↓
   LinePooling (mean pool)
       ↓
   Line Features [L, 768]
       ↓
  ┌────┼────┐
  ↓    ↓    ↓
Stage1 Stage3 Stage4
(分类) (Parent) (Relation)
  ↓    ↓    ↓
L_cls L_par L_rel
       ↓
Total Loss = λ1*L_cls + λ2*L_par + λ3*L_rel
```

### Comp_HRDoc 模型结构 (train_doc.py)

```
预提取的 Region Features
  或
Stage 模型特征 (--use-stage-features)
       ↓
   Order Module (可选)
       ↓
  Construct Module
       ↓
  RoPE Transformer
       ↓
  TreeRelationHead
   ├── Parent Head
   └── Sibling Head
       ↓
L_parent + L_sibling
```

### 当前集成方式

**现状**：`--use-stage-features` 模式
```python
# 使用训练好的 stage 模型提取特征
stage_feature_extractor = StageFeatureExtractor(
    checkpoint_path=args.stage_checkpoint
)
line_features = stage_feature_extractor.extract_features(batch)
# 然后送入 Construct 模块训练
```

**问题**：
- 不是端到端训练，梯度不回传到 backbone
- Stage 模型和 Construct 模块分开优化

### 联合训练方案（TODO）

**目标**：将 Stage backbone 和 Construct 模块端到端联合训练

```
LayoutXLM Backbone (共享)
       ↓
   LinePooling
       ↓
   Line Features
       ↓
  ┌────┴────┐
  ↓         ↓
Stage3/4   Construct
(GRU)     (RoPE+TreeHead)
  ↓         ↓
L_stage   L_construct
       ↓
Total Loss = λ1*L_stage + λ2*L_construct
```

**实现要点**：
1. 复用 `examples/stage/models/joint_model.py` 的 backbone + line_pooling
2. 添加 `ConstructModule` 作为新的 head
3. 设计合理的 loss 权重
4. 可选：保留 Stage3/4 做多任务学习，或只用 Construct

**代码路径**：
- Stage 模型：`examples/stage/models/joint_model.py`
- Construct 模块：`examples/comp_hrdoc/models/construct.py`
- 特征提取器：`examples/comp_hrdoc/utils/stage_feature_extractor.py`

---

## Stage1 联合训练实现（已完成）

### 训练参数

```python
# train_doc.py 核心参数
parser.add_argument("--stage-checkpoint", type=str, required=True,
                    help="Path to pretrained stage checkpoint (contains backbone + cls_head + line_enhancer)")
parser.add_argument("--stage1-lr", type=float, default=2e-5,
                    help="Learning rate for Stage1 components (backbone + cls_head + line_enhancer)")
parser.add_argument("--learning-rate", type=float, default=5e-5,
                    help="Learning rate for Construct module")
parser.add_argument("--freeze-visual", action="store_true", default=False,
                    help="Freeze visual encoder in backbone (save memory)")
parser.add_argument("--lambda-cls", type=float, default=1.0,
                    help="Weight for Stage1 classification loss (optional)")
```

### 复用模块

```python
# 从 stage 复用
from examples.stage.models.modules import LinePooling
from examples.stage.models.heads import LineClassificationHead

# 或完整模型
from examples.stage.models.stage1_line_level_model import LayoutXLMForLineLevelClassification
```

### 联合模型结构

**实现方式**：分离式设计（符合项目结构规范）

```python
# StageFeatureExtractor (封装 Stage1 组件)
class StageFeatureExtractor:
    def __init__(self, checkpoint_path):
        # 加载 JointModel (包含 backbone + line_pooling + cls_head + line_enhancer)
        self.model = JointModel(...)

    def extract_features(self, input_ids, bbox, attention_mask, line_ids, ...):
        # Backbone encoding
        hidden = self.model.encode_with_micro_batch(...)

        # LinePooling
        line_features, mask = self.model.line_pooling(hidden, line_ids)

        # LineFeatureEnhancer (行间 Transformer)
        if self.model.line_enhancer is not None:
            line_features = self.model.line_enhancer(line_features, mask)

        return line_features, mask

# ConstructFromFeatures (Construct 组件)
class ConstructFromFeatures(nn.Module):
    def __init__(self, ...):
        self.construct_module = ConstructModule(...)  # RoPE Transformer + TreeHead

    def forward(self, region_features, categories, ...):
        outputs = self.construct_module(region_features, categories, ...)
        return {"loss": ..., "parent_logits": ..., "sibling_logits": ...}
```

**训练流程**：
```python
# 特征提取（有梯度）
line_features, line_mask = stage_feature_extractor.extract_features(batch)

# Stage1 分类 loss（可选）
cls_logits = stage_feature_extractor.model.cls_head(line_features)
cls_loss = CE(cls_logits, line_labels)

# Construct 前向
outputs = construct_model(region_features=line_features, ...)
construct_loss = outputs["loss"]

# 总损失
total_loss = lambda_cls * cls_loss + construct_loss
total_loss.backward()  # 梯度回传到 backbone
```

### 训练流程

```
1. 加载 Stage Checkpoint (--stage-checkpoint)
   └─ StageFeatureExtractor 自动加载：
      - backbone (LayoutXLM)
      - cls_head (如果有 cls_head.pt)
      - line_enhancer (如果有 line_enhancer.pt)

2. 设置训练模式
   └─ stage_feature_extractor.set_train_mode(freeze_visual=True)

3. 初始化 ConstructModule
   └─ RoPE Transformer (3层) + TreeRelationHead

4. 配置优化器（分层学习率）
   - backbone_params: lr=2e-5 (backbone + cls_head + line_enhancer)
   - construct_params: lr=5e-5 (Construct)

5. 训练循环
   - Extract: line_features = feature_extractor.extract_features(batch)
   - Stage1 Loss (可选): cls_loss = CE(cls_logits, labels)
   - Construct Loss: construct_loss = model(line_features, ...)["loss"]
   - Total: total_loss = lambda_cls * cls_loss + construct_loss
   - Backward: total_loss.backward()  # 梯度回传到全部组件
   - Update: optimizer.step()

6. 保存模型
   - stage1/ (backbone)
   - cls_head.pt
   - line_enhancer.pt
   - pytorch_model.bin (Construct)
```

### 配置要求

| 配置项 | 来源 | 说明 |
|--------|------|------|
| layoutxlm_path | configs/{env}.yml 或命令行 | LayoutXLM 模型路径 |
| num_classes | 固定 14 或从 labels.py | 分类类别数 |
| tokenizer | 与 layoutxlm_path 相同 | 分词器 |

### 使用方法

```bash
# 基础联合训练
python examples/comp_hrdoc/scripts/train_doc.py \
    --env test \
    --stage-checkpoint /path/to/stage/checkpoint \
    --stage1-lr 2e-5 \
    --learning-rate 5e-5 \
    --lambda-cls 1.0

# 冻结视觉编码器（节省显存）
python examples/comp_hrdoc/scripts/train_doc.py \
    --env test \
    --stage-checkpoint /path/to/stage/checkpoint \
    --freeze-visual

# 快速测试
python examples/comp_hrdoc/scripts/train_doc.py \
    --env test \
    --stage-checkpoint /path/to/stage/checkpoint \
    --quick

# 推理
python examples/comp_hrdoc/scripts/predict_doc.py \
    --stage-checkpoint /path/to/stage/checkpoint \
    --construct-checkpoint /path/to/best_model \
    --input-file test.jsonl \
    --output-file predictions.jsonl

# 评估
python examples/comp_hrdoc/scripts/evaluate_doc.py \
    --stage-checkpoint /path/to/stage/checkpoint \
    --construct-checkpoint /path/to/best_model \
    --test-file test.jsonl
```

### 实现文件

**核心模块**（遵循项目结构规范）：

- **utils/**: 特征提取封装
  - `stage_feature_extractor.py`: 统一的特征提取接口

- **models/**: 网络结构
  - `construct.py`: RoPE Transformer + TreeRelationHead
  - `construct_only.py`: ConstructFromFeatures 模型

- **engines/**: 训练/推理/评估循环
  - `predictor.py`: 推理管线

- **scripts/**: 入口脚本
  - `train_doc.py`: 训练入口（联合训练）
  - `predict_doc.py`: 推理入口
  - `evaluate_doc.py`: 评估入口

- **api/**: API 服务
  - `infer_service.py`: FastAPI 推理服务

### 设计优势

1. ✅ **端到端训练**：梯度流通，backbone 适应 Construct 任务
2. ✅ **代码简洁**：删除 use-stage-features 模式，减少 40% 代码量
3. ✅ **统一接口**：训练/推理/评估/API 都使用同一套逻辑
4. ✅ **模块化**：符合项目结构规范，职责清晰
5. ✅ **灵活性**：支持冻结视觉编码器、可选分类 loss
