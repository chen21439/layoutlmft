# Comp_HRDoc 项目设计思路

## 数据

- **Comp_HRDoc** 数据集
- 每个文档包含多行（line），每行有：text、bbox、类别（section/para/fig/tab...）
- **标注**：section 之间的父子关系、左兄弟关系

## 模型流程

```
文本+位置 → LayoutXLM → token embeddings → mean pool → line embeddings
                                                          ↓
                                           只取 section 类的 lines
                                                          ↓
                                         RoPE Transformer (N层)
                                                          ↓
                                           TreeRelationHead
                                            ├── Parent Head
                                            └── Sibling Head
```

## RoPE Transformer

### 结构（每层）
```
Input [B, S, H]
    ↓
LayerNorm
    ↓
┌─────────────────────────────────────┐
│  Self-Attention with RoPE           │
│  Q = W_q(x), K = W_k(x), V = W_v(x) │
│  Q', K' = apply_rope(Q, K, pos)     │
│  Attn = softmax(Q'K'^T / √d) · V    │
│  Output = W_o(Attn)                 │
└─────────────────────────────────────┘
    ↓ (+residual)
LayerNorm
    ↓
┌─────────────────────────────────────┐
│  FFN                                │
│  Linear(H→4H) → GELU → Linear(4H→H) │
└─────────────────────────────────────┘
    ↓ (+residual)
Output [B, S, H]
```

### 关键参数
- `hidden_size`: 768
- `num_heads`: 12
- `num_layers`: 3（默认）
- `ffn_dim`: 3072 (4 × hidden_size)
- `scale`: head_dim^(-0.5) = (768/12)^(-0.5) = 64^(-0.5)

### RoPE 位置编码
- 使用 reading order 作为位置输入
- 对 Q, K 应用旋转位置编码
- 编码 section 在文档中的相对顺序

## TreeRelationHead（两个预测头）

### 结构
```
features [B, S, H]
         ↓
    ┌────┴────┐
    ↓         ↓
Parent Head  Sibling Head
    ↓         ↓
┌─────────┐ ┌─────────┐
│ W_q [H,H]│ │ W_q [H,H]│  ← 全连接层（无bias默认）
│ W_k [H,H]│ │ W_k [H,H]│
└─────────┘ └─────────┘
    ↓         ↓
 Q·K^T/√H   Q·K^T/√H
    ↓         ↓
[B, S, S]  [B, S, S]
```

### 1. Parent Head
```python
Q = W_q(features)           # [B, S, H]
K = W_k(features)           # [B, S, H]
parent_logits = Q @ K^T * scale  # [B, S, S]
# parent_logits[i, j] = j 是 i 的父节点的得分
```
- **自指向（i==j）表示 ROOT**
- 对角线不 mask，允许学习自指向

### 2. Sibling Head
```python
Q = W_q(features)           # [B, S, H]
K = W_k(features)           # [B, S, H]
sibling_logits = Q @ K^T * scale  # [B, S, S]
# sibling_logits[i, j] = j 是 i 的左兄弟的得分
```
- **自指向表示无左兄弟**
- **上三角 mask**：左兄弟只能从前面的节点选（j ≤ i）

## Mask 策略

| 位置 | Parent Head | Sibling Head |
|------|-------------|--------------|
| 对角线 | ✓ 保留（ROOT自指向） | ✓ 保留（无左兄弟） |
| 上三角 | ✓ 保留 | ✗ mask（j > i 不合法） |
| 无效节点 | ✗ mask (-1e4) | ✗ mask (-1e4) |

## 格式转换

| 格式 | 字段 | 含义 | 用途 |
|------|------|------|------|
| 格式 A | ref_parent, relation | 参考父节点 + 关系类型 | 训练数据标注 |
| 格式 B | hierarchical_parent, left_sibling | 自指向方案 | 模型预测输出 |

**自指向约定**：
- `parent[i] = i` → 节点 i 是 ROOT
- `sibling[i] = i` → 节点 i 无左兄弟

## 解码算法：Tree Insertion Decode

推理时使用 Algorithm 1（Joint论文）进行联合解码：

```
for i in 0..N:
    1. 获取候选父节点 = 当前树的"最右路径"上的节点
    2. 从候选中选择 parent_logits 最高的作为父节点
    3. 选择左兄弟（从父节点的已有子节点中选）
    4. 将节点 i 插入树中
```

**最右路径约束**：保证生成的树结构合法

## 损失函数

```python
loss = CE(parent_logits, gt_parents) + CE(sibling_logits, gt_siblings)
```

- 交叉熵损失
- 两个 head 的 loss 直接相加（权重 1:1）

## 核心设计点

1. **只学习相对关系**
   - 没有绝对层级概念（不知道"册"比"章"高）
   - Parent/Sibling 关系是相对的，由上下文决定

2. **Mean Pooling 的信息损失**
   - Token embeddings → Line embeddings 使用 mean pool
   - 关键 token（如"册"、"章"）的信息被平均稀释
   - 一行 20 个 token，"册"只占 1/20 权重

3. **Query-Key 机制**
   - 类似 Attention，但不做 softmax 后加权
   - 直接用 logits 做分类
   - scale factor 防止梯度消失

4. **位置信息来源**
   - RoPE 编码 reading order（section 顺序）
   - 不直接使用 bbox 空间位置

## 已知问题

**"第二册"预测错误**：
- "第一册" 能正确预测 parent=自身（ROOT）
- "第二册" 预测 parent=自身 的得分低，被错误放到其他节点下

**可能原因**：
1. Mean pooling 后，"一" vs "二" 的 embedding 差异被稀释
2. RoPE 位置编码影响了上下文表示（第二册位置靠后）
3. 训练数据中类似 pattern 不足
4. Query-Key 线性变换没有学到区分"首个"vs"非首个"同类节点

**可能的改进方向**：
- 加权 pooling（给开头 token 更高权重）
- Attention pooling 代替 mean pooling
- 增加训练数据中的多册样本
- 显式的位置特征（是否是同类节点中的第一个）

---

## Comp_HRDoc 架构（独立于 stage 目录）

### 目录结构

```
comp_hrdoc/models/
├── detect.py              # Stage1Backbone（backbone + line_pooling + line_enhancer）
├── modules/
│   ├── line_pooling.py    # LinePooling（高效 scatter_add 实现）
│   └── line_transformer.py # LineFeatureEnhancer（论文 4.2.2）
├── heads/
│   └── classification_head.py # LineClassificationHead
├── construct.py           # RoPE Transformer + TreeRelationHead
├── construct_only.py      # ConstructFromFeatures
└── joint_with_stage1.py   # JointModelWithStage1（联合训练）
```

### 模型流程（train_stage1 模式）

```
LayoutXLM Backbone
       ↓
   LinePooling (scatter_add)
       ↓
   LineFeatureEnhancer (论文 4.2.2)
       ↓
   Line Features [L, 768]
       ↓
  ┌────┴────┐
  ↓         ↓
ClsHead    Construct
(分类)    (RoPE+TreeHead)
  ↓         ↓
L_cls    L_construct
       ↓
Total Loss = λ1*L_cls + λ2*L_construct
```

### 核心模块

| 模块 | 文件 | 说明 |
|------|------|------|
| Stage1Backbone | `models/detect.py` | backbone + line_pooling + line_enhancer |
| LinePooling | `models/modules/line_pooling.py` | 高效特征聚合（scatter_add） |
| LineFeatureEnhancer | `models/modules/line_transformer.py` | 行间特征增强（1层 Transformer） |
| LineClassificationHead | `models/heads/classification_head.py` | 分类头 |
| ConstructModule | `models/construct.py` | RoPE Transformer + TreeRelationHead |
| StageFeatureExtractor | `utils/stage_feature_extractor.py` | 特征提取封装 |

### Stage1Backbone 结构

```python
class Stage1Backbone(nn.Module):
    def __init__(self, backbone_model, use_line_enhancer=True):
        self.backbone = backbone_model          # LayoutXLM
        self.line_pooling = LinePooling()       # Token → Line
        self.line_enhancer = LineFeatureEnhancer()  # 可选，论文 4.2.2
        self.cls_head = LineClassificationHead()    # 可选

    def encode_with_micro_batch(self, input_ids, bbox, ...):
        # 分批处理，支持大 batch
        ...

    def extract_line_features(self, input_ids, bbox, ..., line_ids):
        # 完整流程：backbone → line_pooling → line_enhancer
        ...
```

### 与 Stage 目录的对比

| 特性 | comp_hrdoc | stage |
|------|------------|-------|
| 独立性 | ✅ 完全独立 | - |
| LinePooling | 本地实现 | 原始实现 |
| LineFeatureEnhancer | ✅ 支持 | 可选 |
| 层级预测 | RoPE Transformer + TreeHead | GRU (ParentFinder) |
| 训练方式 | `--train-stage1` 联合训练 | train_joint.py |

---

## Stage1 联合训练实现

### 新增参数

```python
# train_doc.py 新增参数
parser.add_argument("--train-stage1", action="store_true", default=False,
                    help="Enable Stage1 (LayoutXLM) joint training with Construct")
parser.add_argument("--layoutxlm-path", type=str, default="microsoft/layoutxlm-base",
                    help="LayoutXLM model path (HuggingFace or local)")
parser.add_argument("--stage1-lr", type=float, default=5e-5,
                    help="Learning rate for Stage1 backbone")
parser.add_argument("--freeze-backbone", action="store_true", default=False,
                    help="Freeze LayoutXLM backbone, only train cls_head + Construct")
parser.add_argument("--lambda-cls", type=float, default=1.0,
                    help="Weight for Stage1 classification loss")
```

### 复用模块

```python
# 从 stage 复用
from examples.stage.models.modules import LinePooling
from examples.stage.models.heads import LineClassificationHead

# 或完整模型
from examples.stage.models.stage1_line_level_model import LayoutXLMForLineLevelClassification
```

### 联合模型结构

```python
class DOCModelWithStage1(nn.Module):
    def __init__(self, layoutxlm_model, construct_model, num_classes=14):
        # Stage1 组件
        self.backbone = layoutxlm_model          # LayoutXLM
        self.line_pooling = LinePooling()        # 共享模块
        self.cls_head = LineClassificationHead() # 共享模块

        # Construct 组件
        self.construct = construct_model         # RoPE Transformer + TreeHead

    def forward(self, input_ids, bbox, attention_mask, line_ids, ...):
        # Stage1: 提取 line features
        hidden = self.backbone(input_ids, bbox, attention_mask)
        line_features, mask = self.line_pooling(hidden, line_ids)
        cls_logits = self.cls_head(line_features)
        cls_loss = CE(cls_logits, line_labels)

        # 过滤 section
        section_features = line_features[section_mask]

        # Construct: 预测 parent/sibling
        construct_out = self.construct(section_features, ...)
        construct_loss = construct_out["loss"]

        # 联合 loss
        total_loss = lambda_cls * cls_loss + lambda_construct * construct_loss
        return total_loss, cls_logits, construct_out
```

### 训练流程

```
1. 加载 LayoutXLM (--layoutxlm-path)
2. 初始化 LinePooling + LineClassificationHead
3. 初始化 ConstructModule (RoPE Transformer + TreeHead)
4. 优化器参数组:
   - backbone: lr=stage1_lr (可选 freeze)
   - cls_head: lr=stage1_lr
   - construct: lr=learning_rate
5. 训练循环:
   - Forward: backbone → line_pooling → cls_head → construct
   - Loss: λ1*L_cls + λ2*L_construct
   - Backward & Update
```

### 配置要求

| 配置项 | 来源 | 说明 |
|--------|------|------|
| layoutxlm_path | configs/{env}.yml 或命令行 | LayoutXLM 模型路径 |
| num_classes | 固定 14 或从 labels.py | 分类类别数 |
| tokenizer | 与 layoutxlm_path 相同 | 分词器 |

### 使用方法

```bash
# 基础 Stage1 + Construct 联合训练
python examples/comp_hrdoc/scripts/train_doc.py \
    --env test \
    --train-stage1 \
    --layoutxlm-path /path/to/layoutxlm \
    --stage1-lr 5e-5 \
    --learning-rate 1e-4 \
    --lambda-cls 1.0 \
    --construct-weight 1.0

# 冻结 backbone，只训练 cls_head + Construct
python examples/comp_hrdoc/scripts/train_doc.py \
    --env test \
    --train-stage1 \
    --freeze-backbone \
    --learning-rate 1e-4

# 快速测试
python examples/comp_hrdoc/scripts/train_doc.py \
    --env test \
    --train-stage1 \
    --quick
```

### 实现文件

- **模型**: `examples/comp_hrdoc/models/joint_with_stage1.py`
  - `JointModelWithStage1`: 联合模型类
  - `build_joint_model_with_stage1`: 模型构建函数

- **训练**: `examples/comp_hrdoc/scripts/train_doc.py`
  - `train_epoch_with_stage1()`: Stage1 训练循环
  - `evaluate_with_stage1()`: Stage1 评估函数
